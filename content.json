{"meta":{"title":"谢昊璋的博客","subtitle":"","description":"","author":"谢昊璋","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-08-28T14:49:15.000Z","updated":"2020-08-30T08:50:50.396Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-08-28T14:46:49.000Z","updated":"2020-08-30T06:06:48.530Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"树莓派使用OpenVINO推理YOLOv5","slug":"树莓派使用OpenVINO推理YOLOv5","date":"2022-03-01T15:21:12.000Z","updated":"2022-03-01T15:21:13.745Z","comments":true,"path":"2022/03/01/树莓派使用OpenVINO推理YOLOv5/","link":"","permalink":"http://yoursite.com/2022/03/01/%E6%A0%91%E8%8E%93%E6%B4%BE%E4%BD%BF%E7%94%A8OpenVINO%E6%8E%A8%E7%90%86YOLOv5/","excerpt":"","text":"系统版本与依赖 Windows 10 64bit Raspbian 64bit for Raspberry Pi OpenVINO_2021.2.185 VS2019 一、 YOLOv5测试及模型导出1.1 环境测试YOLOv5源码地址： https:&#x2F;&#x2F;github.com&#x2F;ultralytics&#x2F;yolov5 克隆项目及配置环境 git clone https:&#x2F;&#x2F;github.com&#x2F;ultralytics&#x2F;yolov5.gitcd yolov5pip install -r requirements.txt 测试 python detect.py --weights yolov5n.pt --source data&#x2F;images&#x2F;bus.jpg --img 640 [ Speed: 1.0ms pre-process, 120.7ms inference, 7.0ms NMS per image at shape (1, 3, 640, 640) 1.2 模型导出为方便YOLOv5模型C端部署，我们将pytorch模型文件转换为开放模型格式ONNX与OpenVINO的IR文件。 # 使用Yolov5项目中的脚本转换python models/export.py --weights yolov5s.pt --img 640 --batch 1# 使用OpenVINO的model optimizer工具python mo_onnx.py --input_model E:\\YOLOv5_OpenVINO\\YOLOv5n_openvino\\model\\yolov5n.onnx 二、YOLOv5的C端实现2.1 OpenVINO环境测试model_optimizer 配置 cd C:\\Program Files (x86)\\Intel\\openvino_2021.2.185\\binsetupvars.batcd C:\\Program Files (x86)\\Intel\\openvino_2021.2.185\\deployment_tools\\model_optimizer\\install_prerequisitesinstall_prerequisites.bat 测试demo C:\\Program Files (x86)\\Intel\\openvino_2021.2.185\\deployment_tools\\demodemo_security_barrier_camera.bat 2.2 OpenVINO推理Yolov5YOLOv5的输出层是3层，分别对应32倍降采样、16倍降采样、8倍降采样。假设我们输入图像的是640x640，那么三个输出层大小分别是20、40以及80，每个层对应三个尺度的anchor。模型在每个输出层的每个特征点上预测三个框，每个框的维度为cx、cy、w、h、conf以及class。YOLOv5预训练模型基于的COCO数据有80个对象类别，则通过Netron可视化模型可以观察到模型输出如下图所示 然后循环每个输出层，解析每个特征点对应的 3 个框与相关数据。由于在导出的时候 ONNX 格式文件时模型的推理得到的三个输出层原始结果，所以还需要对每个数据先完成 sigmoid 归一化，然后再计算相关值，这部分的代码实现我参考了项目中的 yolo.py 中的 Detection 部分，得到初始每个对象的检测框之后，采用 OpenVINO 中自带非最大抑制函数，完成非最大抑制，就得到了最终的预测框，然后绘制显示。所以最终的解析输出层部分的代码如下： for (int i = 0; i &lt; side_square; ++i) &#123; for (int c = 0; c &lt; out_c; c++) &#123; int row = i / side_h; int col = i % side_h; int object_index = c*side_data_square + row*side_data_w + col*side_data; // 阈值过滤 float conf = sigmoid_function(output_blob[object_index + 4]); if (conf &lt; 0.25) &#123; continue; &#125; // 解析cx, cy, width, height float x = (sigmoid_function(output_blob[object_index]) * 2 - 0.5 + col)*stride; float y = (sigmoid_function(output_blob[object_index + 1]) * 2 - 0.5 + row)*stride; float w = pow(sigmoid_function(output_blob[object_index + 2]) * 2, 2)*anchors[anchor_index + c * 2]; float h = pow(sigmoid_function(output_blob[object_index + 3]) * 2, 2)*anchors[anchor_index + c * 2 + 1]; float max_prob = -1; int class_index = -1; // 解析类别 for (int d = 5; d &lt; 85; d++) &#123; float prob = sigmoid_function(output_blob[object_index + d]); if (prob &gt; max_prob) &#123; max_prob = prob; class_index = d - 5; &#125; &#125; // 转换为top-left, bottom-right坐标 int x1 = saturate_cast&lt;int&gt;((x - w / 2) * scale_x); // top left x int y1 = saturate_cast&lt;int&gt;((y - h / 2) * scale_y); // top left y int x2 = saturate_cast&lt;int&gt;((x + w / 2) * scale_x); // bottom right x int y2 = saturate_cast&lt;int&gt;((y + h / 2) * scale_y); // bottom right y // 解析输出 classIds.push_back(class_index); confidences.push_back((float)conf); boxes.push_back(Rect(x1, y1, x2 - x1, y2 - y1)); // rectangle(src, Rect(x1, y1, x2 - x1, y2 - y1), Scalar(255, 0, 255), 2, 8, 0); &#125;&#125; GPU: 三、树莓派配置OpenVINO环境参考文档：https://docs.openvino.ai/latest/openvino_docs_install_guides_installing_openvino_raspbian.html 3.1 OpenVINO安装OpenVINO版本：l_openvino_toolkit_runtime_raspbian_p_2021.2.185 此版本是官方发布的适用于Raspbian的OpenVINO toolkit，如果是Raspbian系统则不建议使用Ubuntu版本的OpenVINO套件。 tar -xf l_openvino_toolkit_runtime_raspbian_p_2021.2.185.tgzecho &quot;&#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;l_openvino_toolkit_runtime_raspbian_p_2021.2.185&#x2F;bin&#x2F;setupvars.sh&quot; &gt;&gt; ~&#x2F;.bashrcsudo usermod -a -G users &quot;$(whoami)&quot; 3.2 测试人脸检测demo# 临时环境变量source ~&#x2F;Downloads&#x2F;l_openvino_toolkit_runtime_raspbian_p_2021.2.185&#x2F;bin&#x2F;setupvars.sh# NCS2的USB规则sh &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;l_openvino_toolkit_runtime_raspbian_p_2021.2.185&#x2F;install_dependencies&#x2F;install_NCS_udev_rules.sh # 找一个目录mkdir buildcd buildcmake -DCMAKE_BUILD_TYPE&#x3D;Release -DCMAKE_CXX_FLAGS&#x3D;&quot;-march&#x3D;armv7-a&quot; &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;l_openvino_toolkit_runtime_raspbian_p_2021.2.185&#x2F;deployment_tools&#x2F;inference_engine&#x2F;samples&#x2F;cppmake -j2 object_detection_sample_ssdwget --no-check-certificate https:&#x2F;&#x2F;download.01.org&#x2F;opencv&#x2F;2020&#x2F;openvinotoolkit&#x2F;2020.1&#x2F;open_model_zoo&#x2F;models_bin&#x2F;1&#x2F;face-detection-adas-0001&#x2F;FP16&#x2F;face-detection-adas-0001.binwget --no-check-certificate https:&#x2F;&#x2F;download.01.org&#x2F;opencv&#x2F;2020&#x2F;openvinotoolkit&#x2F;2020.1&#x2F;open_model_zoo&#x2F;models_bin&#x2F;1&#x2F;face-detection-adas-0001&#x2F;FP16&#x2F;face-detection-adas-0001.xml.&#x2F;armv7l&#x2F;Release&#x2F;object_detection_sample_ssd -m face-detection-adas-0001.xml -d MYRIAD -i &#x2F;home&#x2F;pi&#x2F;YOLOv5n_openvino&#x2F;test&#x2F;bus.jpg 四、Cmake编译CMakeList.txt cmake_minimum_required(VERSION 2.8.3)project(OpenVINO_TEST)set(OPENVINO_INCLUDE &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;openvino_2020&#x2F;inference_engine&#x2F;include)set(OPENCV_INCLUDE &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;openvino_2020&#x2F;opencv&#x2F;include)set(OPENVINO_LIB &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;openvino_2020&#x2F;inference_engine&#x2F;lib&#x2F;armv7l)set(OPENCV_LIB &#x2F;home&#x2F;pi&#x2F;Downloads&#x2F;openvino_2020&#x2F;opencv&#x2F;lib)include_directories($&#123;OPENVINO_INCLUDE&#125; $&#123;OPENCV_INCLUDE&#125;)link_directories($&#123;OPENVINO_LIB&#125; $&#123;OPENCV_LIB&#125;)add_executable(main main.cpp)target_link_libraries(main HeteroPlugin inference_engine inference_engine_c_api inference_engine_nn_builder inference_engine_preproc myriadPlugin)target_link_libraries(main opencv_calib3d opencv_core opencv_dnn opencv_features2d opencv_flann opencv_gapi opencv_highgui opencv_imgcodecs opencv_imgproc opencv_ml opencv_objdetect opencv_photo opencv_stitching opencv_video opencv_videoio opencv_videoio_ffmpeg opencv_videoio_gstreamer)#add_definitions(-D_GLIBCXX_USE_CXX11_ABI&#x3D;0) mkdir build cd buildcmake -DCMAKE_BUILD_TYPE&#x3D;Release ..make","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"引用(Reference)","slug":"引用","date":"2020-08-30T08:31:12.000Z","updated":"2021-01-15T09:38:47.613Z","comments":true,"path":"2020/08/30/引用/","link":"","permalink":"http://yoursite.com/2020/08/30/%E5%BC%95%E7%94%A8/","excerpt":"","text":"1.引用即别名&emsp;&emsp;引用并非对象，相反地，它只是为一个已经存在的对象所起的另一个名字。定义了一个引用以后，对其进行的所有操作都是在与之绑定的对象上进行的。 2.引用和指针&emsp;&emsp;引用的本质是指针，引用是C++对裸露的内存地址（指针）做的包装。 1. 可以定义指针的引用，但不能定义引用的引用 指针的引用 ：rpa 绑定的是一个地址。 int a = 100;int *pa = &amp;a;int * &amp;rpa = pa; 引用的引用 ：与指针不同的是，引用没有二级引用，也就是说引用int&amp;类型对象的对象也是int&amp;类型。 int a = 100;int &amp;b = a;// int &amp;&amp; c = a; //errorint &amp; c = a; //ok 2. 可以定义指针的指针，但不能定义引用的指针 指针的指针 ：指向指针的指针也就是二级指针，在C++中这是合法的。 int a = 100;int * pa = &amp;a;int **ppa = &amp;pa; 引用的指针 ：引用只是一个别名。 int a = 100;int &amp; ra = a;// int&amp;* rpa = &amp;ra; // error 3. 可以定义指针数组，但不能定义引用数组，可以定义数组引用 指针数组 :即存放指针(地址)的数组 int a, b, c;int* arr[] = &#123;&amp;a, &amp;b, &amp;c&#125;; 引用数组 :非法定义，r是一个数组的首地址，int &amp;r[]相当于int&amp;*，前面提到引用的指针是不合法的。int a, b, c;// int &amp;r [] = {a, b ,c}; //error 数组引用 :arr 是int [5] 类型int arr[] = {1,2,3,4,5};int (&amp;rarr)[5] = arr; 3.常引用","categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/categories/C/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"}]}